# reactive 原理
我们知道在 vue3 中，我们可以通过 reactive api 将一个对象变为响应式对象：
```
<template>
  <div>
    <div>{{ value.msg }}</div>
    <button @click="change">change</button>
  </div>
</template>
<script>
  import { reactive } from 'vue'
  export default {
    setup() {
      const value = reactive({
        a: 1
      })

      const change = function() {
        state.msg = 2
      }

      return {
        change,
        value
      }
    }
  }
</script>
```

在上面这段代码里，我们可以通过 `reactive` 语法将 value 变为一个响应式对象，当我们点击 button，`value.a` 的值就会改变，从而导致 template 的重新渲染；这就是 vue 响应式的特征。  
那么 `reactive` 是如何实现的呢？下面一起来看一下：
## reactive
reactive api 相关代码：  
``` javascript
// 文件路径 packages/reactivity/src/reactive.ts
const enum ReactiveFlags {
  SKIP = '__v_skip',
  IS_REACTIVE = '__v_isReactive',
  IS_READONLY = '__v_isReadonly',
  IS_SHALLOW = '__v_isShallow',
  RAW = '__v_raw'
}

function reactive(target) {
  // 1，判断 target 上有没有 __v_isReadonly 属性，如果有则直接返回 target 对象，不进行后续操作
  if (isReadonly(target)) {
    return target
  }
  // 2. 否则使用 createReactiveObject 函数，将 target 包装成响应式对象
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  )
}

function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {
  // 3. 判断 target 是不是对象/数组类型，如果不是在 dev 环境下会抛出警告并返回
  if (!isObject(target)) {
    if (__DEV__) {
      console.warn(`value cannot be made reactive: ${String(target)}`)
    }
    return target
  }
  // 4. 判断 target 上有没有 __v_raw 属性(有则说明已经被 Proxy 代理过了)，如果有，并且 (isReadonly 和 target[ReactiveFlags.IS_REACTIVE]) 为 同时false
  // 则直接返回 target
  if (
    target[ReactiveFlags.RAW] &&
    !(isReadonly && target[ReactiveFlags.IS_REACTIVE])
  ) {
    return target
  }
  // 5. 这里的 proxyMap 是一个 WeakMap， map 的键是 target，值是通过 new Proxy 代理 target 后的返回对象
  // 如果 target 已经被代理过，则直接返回代理过的对象
  const existingProxy = proxyMap.get(target)
  if (existingProxy) {
    return existingProxy
  }
  // 6. 判断 target 的类型是否可以变为响应式对象
  // 只有 Object、Array、Map、Set、WeakMap、WeakSet 这几种类型可以通过 reactive api 变为响应式对象
  const targetType = getTargetType(target)
  if (targetType === TargetType.INVALID) {
    return target
  }
  // 7. 通过 new Proxy 劫持 target 将它变为响应式对象
  // 并通过 proxyMap.set(target, proxy) 记录在 WeakMap 中
  // 这里如果 target 是 Map/Set/WeakMap/WeakSet 则 Proxy 的 handler 为 collectionHandlers(mutableCollectionHandlers)
  // 如果 target 是 Object/Array 则 Proxy 的 handler 为 baseHandlers(mutableHandlers)
  const proxy = new Proxy(
    target,
    targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers
  )
  proxyMap.set(target, proxy)
  return proxy
}

function isReadonly(value) {
  return !!(value && value[ReactiveFlags.IS_READONLY])
}
``