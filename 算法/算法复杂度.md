# 为什么要计算复杂度而不是直接运行代码？
通过跑算法得到的数据往往具有一定局限性：
1. 测试结果依赖测试环境性能；  
2. 测试结果受数据规模的影响较大，比如对于小规模的测试数据，插入排序可能还比快速排序快；

# 如何计算复杂度
下面这段代码，求 1 + 2 + 3...n 的累加和：
  ```javascript
    function cal(n) {
      // 执行 1 次
      let sum = 0
      // 执行 1 次
      let i = 1
      // 执行 n 次
      for (; i < n; ++i) {
        // 执行 n 次
        sum = sum + i
      }
      return sum
    }
  ```
循环语句共执行了 2n 次，而循环外的语句执行了 2 次，假设执行一次的时间是 unit_time，**那么总的执行时间就是（2n+2）乘 unit_time**  

**所有代码的执行时间 T(n) 与每行代码的执行次数 f(n) 成正比。**

这种关系可以用公式表示为 *T(n) = O(f(n))*；
对于我们的例子就是 *T(n) = O(2n+2)*；
当 n 很大时，你可以把它想象成 10000、100000。而公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。我们只需要记录一个最大量级就可以了，如果用大 O 表示法表示刚讲的那两段代码的时间复杂度，就可以记为：T(n) = O(n)；

# 分析时间复杂度技巧
1. 只关注循环次数最多的一段代码；
2. 总的时间复杂度就等于量级最大的那段代码的时间复杂度；
3. 嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。

# 常见时间复杂度量级
* 常量阶 O(1)  
只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1);  

  ```javascript
    let i = 0
    let j = 1
    let sum = i + j
  ```  

* 对数阶 O(logn)
  ```javascript
    let i = 0
    while (i <= n) { i = i * 2 }
  ```
* 线性对数阶 O(nlogn)
  ```javascript
    let i = 0
    for (let j = 0; j < n; j++) {
      while (i <= n) { i = i * 2 }
    }
  ```
* 线性阶 O(m + n)  
代码的复杂度由两个数据的规模来决定
  ```javascript
    for (let i = 0; i < m; i++) {
    }
    for (let j = 0; j < n; j++) {
    }
  ```
* 平方阶 O(n²)
* 立方阶 O(n³)
* n次方阶 O(nⁿ)
* 指数阶 O(2ⁿ)
* 阶乘阶 O(n!)

# 空间复杂度
表示算法的存储空间与数据规模之间的增长关系。
  ```javascript
    function print () {
      let i = 0
      let a = new Array(n)
      for (i; i = 0; --i) {
        console.log(a[i])
      }
      for (i = n-1; i >= 0; --i) { 
        console.log(a[i])
      }
    }
  ```
在上述代码中，申请了一个空间存储变量 i，但是它是常量阶的，跟数据规模 n 没有关系，所以我们可以忽略。还有一个大小为 n 的数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。

