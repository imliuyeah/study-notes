# 为什么要计算复杂度而不是直接运行代码？
通过跑算法得到的数据往往具有一定局限性：
1. 测试结果依赖测试环境性能；  
2. 测试结果受数据规模的影响较大，比如对于小规模的测试数据，插入排序可能还比快速排序快；

# 如何计算复杂度
下面这段代码，求 1 + 2 + 3...n 的累加和：
  ```javascript
    function cal(n) {
      // 执行 1 次
      let sum = 0
      // 执行 1 次
      let i = 1
      // 执行 n 次
      for (; i < n; ++i) {
        // 执行 n 次
        sum = sum + i
      }
      return sum
    }
  ```
循环语句共执行了 2n 次，而循环外的语句执行了 2 次，假设执行一次的时间是 unit_time，**那么总的执行时间就是（2n+2）乘 unit_time**  

**所有代码的执行时间 T(n) 与每行代码的执行次数 f(n) 成正比。**

这种关系可以用公式表示为 *T(n) = O(f(n))*；
对于我们的例子就是 *T(n) = O(2n+2)*；
当 n 很大时，你可以把它想象成 10000、100000。而公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。我们只需要记录一个最大量级就可以了，如果用大 O 表示法表示刚讲的那两段代码的时间复杂度，就可以记为：T(n) = O(n)；

# 分析时间复杂度技巧
1. 只关注循环次数最多的一段代码；
2. 总的时间复杂度就等于量级最大的那段代码的时间复杂度；
3. 嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。

# 常见复杂度量级
* 常量阶 O(1)
* 对数阶 O(log(n))
* 线性阶 O(n)
* 线性对数阶 O(nlog(n))
* 平方阶 O(n²)
* 立方阶 O(n³)
* n次方阶 O(nⁿ)
* 指数阶 O(2ⁿ)
* 阶乘阶 O(n!)


