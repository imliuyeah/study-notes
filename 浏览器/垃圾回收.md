
[toc]

参考：「硬核JS」[你真的了解垃圾回收机制吗](https://juejin.cn/post/6981588276356317214#heading-13)

# 总结

    垃圾回收策略主要有：

- 标记清除法（目前主流）
- 引用计数法

V8在标记清除法上又做了一些优化，例如：将对象分为 **新生代** 和 **老生代**，采用不同策略进行垃圾回收。

对 **新生代** 的垃圾采取开启辅助线程 **并行回收** 的方法；

对 **老生代** 的垃圾采用 **增量标记** 的方法来标记活动对象和非活动对象，使得 **JS脚本 和 垃圾回收 可以交替执行**，同时在清理的时候，采用 **惰性清理** 的策略，当内存不够的时候再按需去清理内存；此外，还有 **并发回收** 的策略，开启辅助线程，使得  **JS脚本 和 垃圾回收 可以同时执行**。

# 什么是垃圾回收

    垃圾回收就是释放程序不用的内存，或者是之前用过了，以后不会再用的内存空间。

    比如说下面这个例子：

```js
let test = {
  name: "isboyjc"
};
test = [1,2,3,4,5]
```

    一开始，test 引用了一个对象，这个对象被保存在堆内存中，紧接着我们将 test 变量重新赋值了一个数组，之前被 test 引用的变量就没有用了，那么这个变量占用的内存应该要被释放。

# 垃圾回收策略

    `JavaScript` 垃圾回收机制的原理其实就是 **定期** 找出那些不再用到的内存（变量），然后释放其内存。

## 标记清除算法

    大致过程如下：

1. 在运行时，假设所有的变量都是垃圾，给所有的变量都加上一个标记0；
2. 然后从各个根对象（全局window对象、文档DOM树等）开始遍历，把使用到的变量标记未1；
3. 清理所有标记为0的垃圾，回收内存空间；
4. 最后，再把所有变量标记为0，准备下一轮回收。

### 优点

    实现简单，只需要标记 0 和 1。

### 缺点

- 会导致内存空间不连续。

    

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12247ac3d8f249a5ab85b9b40ba1147b~tplv-k3u1fbpfcp-zoom-1.image" alt="img" style="zoom:50%;" />


- 导致内存分配的速度慢。

  我们在为新的对象分配内存时，假设需要 size 大小，因为内存空间不连续，则需要对空闲的内存遍历一次，找到能容纳 size 大小的空间，一般有如下三种策略：

  - `First-fit`，找到大于等于 `size` 的块立即返回
  - `Best-fit`，遍历整个空闲列表，返回大于等于 `size` 的最小分块
  - `Worst-fit`，遍历整个空闲列表，找到最大的分块，然后切成两部分，一部分 `size` 大小，并将该部分返回

  这三种策略里面 `Worst-fit` 的空间利用率看起来是最合理，但实际上切分之后会造成更多的小块，形成内存碎片，所以不推荐使用，对于 `First-fit` 和 `Best-fit` 来说，考虑到分配的速度和效率 `First-fit` 是更为明智的选择。

### 标记整理（Mark-Compact）算法

    标记整理算法 可以解决标记算法内存不连续的缺点，V8 引擎就是采用这种算法。

    它的标记阶段和标记清除算法没有什么不同，只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存（如下图）：

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c04b0a5a40084e0ba4550500c57f2270~tplv-k3u1fbpfcp-zoom-1.image" alt="img" style="zoom: 50%;" />

## 引用计数算法

    引用计数是一种比较早的垃圾回收算法，它是根据**对象有没有被其它对象引用** 来进行垃圾回收。

    大致过程如下：

1. 如果声明了一个变量，并且把一个引用类型赋值给这个变量，这个值的引用次数记作1；
2. 如果同一个值又被赋给另一个变量，则引用次数加1；
3. 如果这个变量的值被其他值赋给了，那么引用次数减1；
4. 当值的引用次数变为0的时候，就可以进行垃圾回收了。

```js
let a = new Object() 	// 此对象的引用计数为 1（a引用）
let b = a 		// 此对象的引用计数是 2（a,b引用）
a = null  		// 此对象的引用计数为 1（b引用）
b = null 	 	// 此对象的引用计数为 0（无引用）
...			// GC 回收此对象
```

### 优点

    不需要像标记清除算法一样，定期去找不需要的变量。

### 缺点

- 需要一个计数器，会占据很大的空间；
- 如果有循环引用的变量，会导致这种方法失效。

# V8 引擎对垃圾回收的优化

    V8 引擎将堆内存分为**新生代** 和 **老生代** 来采用不同的垃圾回收策略。

## 分代式垃圾回收

    V8 中将堆内存分为新生代和老生代两区域，采用不同的垃圾回收器也就是不同的策略管理垃圾回收。

### 优点

    分代式机制把一些新、小、存活时间短的对象作为新生代，采用一小块内存频率较高的快速清理，而一些大、老、存活时间长的对象作为老生代，使其很少接受检查，新老生代的回收机制及频率是不同的，可以说此机制的出现很大程度提高了垃圾回收机制的效率。

### 新生代垃圾回收

    将堆内存分为两块：**使用区** 与 **空闲区**；

- 新加入的对象放入 **使用区**；
- 进行垃圾回收时，对使用区中的 **活动对象** 做标记，标记完成后将使用区的 **活动对象**，复制到空闲区并排序；
- 清理使用区 **非活动对象** 占用的空间，这样使用区就空出来了，而 **空间区** 现在则保存着 **活动对象**。
- 最后将 **使用区** 与 **空闲区** 进行互换。

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa2d5ad1d89b4b7b919f20e4a5f8973a~tplv-k3u1fbpfcp-zoom-1.image" alt="img" style="zoom:50%;" />

### 老生代垃圾回收

    大多数占用空间比较大、存活时间比较长的对象会被分配到**老生代垃圾回收** 中。

    老生代垃圾回收其实就是使用**标记清除算法**，再通过 **标记整理算法** 来解决内存不连续的问题。

## 并行回收

    垃圾回收的时候，会阻塞 JS 脚本的执行，因此 V8引擎使用了多个辅助线程，来加快垃圾回收的处理速度。

## 增量标记与惰性清理

### 增量标记

    增量就是将垃圾回收的过程，分成许多阶段， JS脚本交替执行。

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e16d93c2c8414d3ab7eac55c852c678a~tplv-k3u1fbpfcp-zoom-1.image" alt="img" style="zoom:50%;" />

    那么要如何知道从垃圾回收进行到了哪里呢？也就是说，当从 JS脚本 切换回垃圾回收时，要从哪里继续呢？V8 引擎使用了**三色标记法** 来解决这个问题。

#### 三色标记法

三色标记法就是使用每个对象的 **两个标记位** 和一个 **标记工作表** 来实现标记，两个标记位编码三种颜色：白、灰、黑

- 白色指的是未被标记的对象
- 灰色指自身被标记，成员变量（该对象的引用对象）未被标记
- 黑色指自身和成员变量皆被标记

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b012d88c1f064eaebd0df60a9aadb85e~tplv-k3u1fbpfcp-zoom-1.image" alt="img" style="zoom:50%;" />

    过程如下：

1. 最初所有的对象都是白色，代表回收器还没有标记它们；
2. 从根对象（全局window对象、根DOM树等）开始，将这组根对象  **标记为灰色**，并 **推入标记工作表**；
3. 回收器从 **标记工作表** 中弹出对象，并访问该对象的 **引用对象**，将 **该对象由灰变为黑**，并将该对象的下一个 **引用对象置灰**；
4. 这样一直到 **没有可以标记为灰色** 的对象时，说明已经 **没有可达（没有引用）对象** 了，那么剩下的白色对象都是无法达到的，是要被回收的对象（图中C、E）

使用三色标记法，当我们从 JS 脚本切换回垃圾回收时，就可以直接从 **标记为灰色** 的对象开始。

#### 写屏障

    考虑这么一种可能性：由于垃圾回收和 JS脚本 是交替执行的，那么在 JS脚本 执行期间有可能**改变已经引用的指针，使得已经引用的对象失去引用，而另一个新引用的对象，此时却被标记为黑色**，这样的话会导致新引用的对象被错误的回收，如下图：

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bada1914eff449b48b5a14e53c107ff3~tplv-k3u1fbpfcp-zoom-1.image" alt="img" style="zoom:50%;" />

    如何解决这个问题呢？

    V8 增量回收使用**写屏障 (Write-barrier)** 机制，**即一旦有黑色对象引用白色对象**，该机制会强制将 **引用的白色对象改为灰色**，从而保证下一次增量 `GC` 标记阶段可以正确标记，这个机制也被称作 **强三色不变性**。

### 惰性清理

    增量标记讨论的是**如何去标记活动对象与非活动对象**，而惰性清理，则是 **V8引擎在释放内存时采取的优化手段**。

    惰性清理指的是：

- 如果内存足够，可以适当延迟清理时间；
- 不会一次性清理所有非活动对象占用的内存，而是根据需要来清理；直到所有的非活动对象内存都清理完毕，后面再接着执行增量标记。

## 并发回收

    并发回收是指，主线程在执行 JS脚本，而辅助线程在后台完成执行垃圾回收，且不阻塞 JS脚本 的执行。

    但是由于两者同时进行，在垃圾回收的过程中，引用的对象随时可能会被更改，因此需要额外的**读写锁** 的机制来避免这种问题。
