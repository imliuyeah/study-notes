# 原型链继承
## 原型链
首先每个构造函数（其实是每个函数都有）都有一个原型对象，同时原型有一个属性回指构造函数，而实例内部有一个指针 `[[prototype]]`（`__ptoto__`） 指向原型；  
**原型又可以看做是另一个构造函数的实例**，那么对于原型来说，它也有一个内部指针 `[[prototype]]`（即 `__ptoto__`）指向它的原型；  
那么这个原型链什么时候到头呢？  
实际上，任何函数的默认原型都是一个Object的实例，所以原型链的尽头就是 Object 原型的原型，即 `Object.prototype.__ptoto__`，我们可以用 `Object.getPrototypeOf(Object.prototype)` 获取，它的值为 null；

## 原型链继承代码
原型链继承就是基于这个思想：通过把自己的原型指向另外一个构造函数的实例对象，从而"继承"这个对象上的属性、方法
```js
  function SuperType() {
    this.property = true;
  }
  SuperType.prototype.getSuperValue = function() {
    return this.property;
  };
  function SubType() {
    this.subproperty = false;
  }
  // 让 SubType 这个构造函数的原型指向 SuperType 的实例
  SubType.prototype = new SuperType();
  SubType.prototype.getSubValue = function () {
    return this.subproperty;
  };
  let instance = new SubType();
  console.log(instance.getSuperValue()); // true
```
这个例子中实现继承的关键，是SubType没有使用默认原型，而是将其替换成了一个新的对象。这个新的对象恰好是SuperType的实例。这样一来，SubType的实例不仅能从SuperType的实例中继承属性和方法，而且还与SuperType的原型挂上了钩。
## 问题
* 原型中包含的引用值会在所有实例间共享；
```js
  function SuperType() {
    this.colors = ["red", "blue", "green"];
  }
  function SubType() {}
  // 继承SuperType
  SubType.prototype = new SuperType();
  let instance1 = new SubType();
  instance1.colors.push("black");
  console.log(instance1.colors); // "red, blue, green, black"
  let instance2 = new SubType();
  console.log(instance2.colors); // "red, blue, green, black"
```
* 子类型在实例化时不能给父类型的构造函数传参，所有类型的默认值都是相同的，不能够定制化； 

# 借用构造函数继承
使用原型链继承原型上的属性和方法，而通过借用构造函数继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。来看下面的例子：
```js
  function Parent () {
    this.names = ['kevin', 'daisy'];
  }
  function Child () {
    Parent.call(this);
  }
  var child1 = new Child();
  child1.names.push('yayu');
  console.log(child1.names); // ["kevin", "daisy", "yayu"]
  var child2 = new Child();
  console.log(child2.names); // ["kevin", "daisy"]
```