参考：https://stackoverflow.com/questions/25915634/difference-between-microtask-and-macrotask-within-an-event-loop-context/30910084#30910084

# event loop

1. 首先，我们的 js 代码都是在执行栈上被执行的

2. 当代码在执行的过程中，遇上异步任务的回调、或者触发的一些操作，会被放在 任务队列 里

3. 任务队列的话又分为两种，宏任务队列和微任务队列

   - 宏任务队列：scirpt、setTimeout、setImmediate、postMessage 等

   - 微任务队列：promise.then、MutationObsever

4. 一般执行栈中最开始执行的都是我们整体的 script ，当我们的执行栈中的宏任务代码都被执行完毕以后，会去微任务队列中读取最早加入的任务，放入执行栈中执行，重复读取执行这个过程，一直到本次微任务队列清空；

5. 这个时候如果是浏览器环境的话，浏览器可能会进行一些重新渲染的操作；

6. 那么这样就完成了一次事件循环；

7. 接着开启下一次事件循环，又会先从宏任务队列中读取一个任务执行，然后再去清空微任务队列。



```js
function app() {
  setTimeout(() => {
    console.log("1-1");
    Promise.resolve().then(() => {
      console.log("2-1");
    });
  });
  console.log("1-2");
  Promise.resolve().then(() => {
    console.log("1-3");
    setTimeout(() => {
      console.log("3-1");
    });
  });
}
app();
```



上面这段代码，正确的输出如下：

```js
1-2
1-3
1-1
2-1
3-1
```

**注意，这里 2-1，在 3-1之前输出了。**

执行过程大致如下：

1. 函数 `app()` 被调用，相关内容入栈，开始执行代码；
2. 遇到第一个 `setTimeout()` 相关的回调被放入 **宏任务队列**，代码继续往下执行；
3. 遇到 `console.log()`，**输出 1-2**，代码继续往下执行；
4. 遇到 `Promise.then()`，将其回调放入 **微任务队列**；
5. 当前代码执行完毕，函数 `app` 出栈，执行栈被清空；
6. 从 **微任务队列** 中读取任务执行，于是第一个 `Promise.then()` 的回调被推入执行栈，**输出 1-3**；
7. 此时遇到第二个 `setTimeout()`，将它的相关回调也放入 **宏任务队列**；
8. 现在执行栈又清空了，再次检查 **微任务队列**，微任务队列中也没有任务，那么此时浏览器可能会进行一些重新渲染之类的操作；
9. **那么一轮事件循环就完成了，接下来开启下一轮的事件循环**；
10. 新一轮事件循环会再次去 **宏任务队列** 中寻找任务，将 宏任务队列 中的第一个任务，也就是第一个 `setTimeout()` 推入执行栈，**输出 1-1**；
11. 这时遇到第二个 `Promise.then()`，将其回调放入 **微任务队列**；
12. 第一个 `setTimeout` 执行完毕，执行栈被清空，再次到 **微任务队列** 中寻找任务，找到了第二个 `Promise.then()` 并执行，**输出 2-1**；
13. 最后 **微任务队列** 中的任务执行完毕，再次到 **宏任务队列** 中寻找任务，找到了第二个 `setTimeout()` 并执行，**输出 3-1** 



**关键点**：

- `<script>` 标签中的 js 代码，整体也是一个宏任务；

- 当执行栈被清空了以后，会一个一个取任务队列中的任务，而不是一次性将任务队列中的任务全部推入执行栈；
- 每次执行栈的任务执行完毕后，会先检查微任务队列并依次执行所有微任务，等到微任务执行完毕后再去执行宏任务队列的任务，以此不断循环。
- 微任务队列中的任务将在本轮运行，而宏任务队列中的任务必须等待下一轮事件循环。
- 当任务（在宏任务队列中）运行时，可能会注册新事件。因此可能会创建新任务。以下是两个新创建的任务：
  - promiseA.then() 的回调是一个任务
    - promiseA 被解决/拒绝：任务将在当前轮事件循环中被推入微任务队列。
    - promiseA 未决：该任务将在未来一轮的事件循环中被推入微任务队列（可能是下一轮）
  - setTimeout(callback,n)的回调是一个任务，会被推入macrotask队列，即使n为0；